谈谈前端模块化的那些坑
======================

首先我觉得有必要解释一下什么叫做前端工程化。

### 脚本模块化

模块化能力可以理解为对复杂系统的分解能力。由于Javascript直到ES6之前，都没有提供原生的module支持，因此在实际运用中，整个社区都在不断的尝试新的方式来解决模块化问题。

虽然不是本文的重点，但是我们可以在这里稍微回顾一下大概的几种尝试：

- 基于函数

	这可以说是Javascript的刀耕火种时期，在Web2.0到来之前，Javascript需要提供的功能也很少，但是通常还是会独立抽出一个脚本文件命名为common.js或util.js来保存一些通用的函数。

- 基于对象封装

    使用基于函数的方式，我们就会碰到函数名冲突、互相覆盖、难以管理的问题，因此我们很自然的利用面向对象思想来进行改进。通过闭包特性、引入命名空间等等各式各样的模块化写法，我们可以较好的处理上述问题。

- 基于模块加载器

   实际基于对象封装已经可以在功能上满足模块化开发的能力，但是繁琐的命名空间、不健全的依赖声明手段都让模块化开发体验非常不人性，通过类似RequireJs、SeaJs等模块化加载器的引入，优雅的解决了命名冲突、依赖声明的问题，顺便还解决了按需加载的问题。

虽然在拥有高大上的模块加载器后，Javascript模块化的开发体验这个坑算是填上了，但是我们还是没办法高枕无忧，不过我们暂且不表，先看看下一个坑。

### URI路径

为什么说URI路径是个坑呢？举个例子，在一个传统Web项目中，我们的目录结构可能会是这样：

```bash
.  
├── js  
│   └── logo.js  
├── image  
│   ├── logo_1.png
│   └── logo_2.png  
├── css  
│   └── logo.css
├── misc
│   └── about.html
└── index.html
```

出于某些蛋疼的原因，我们可能会希望页面的LOGO可以定时在logo_1.png和logo_2.png间切换，因此我们会想到用脚本来控制logo的图片。那么我们通过指定图片的相对路径URI，就可以在脚本中为图片元素指定图片的路径。

```javascript
var img = '../image/logo.png';
document.getElementsById('logo').src = img;
```

看起来一切都很美好，没有什么问题，我们平时也都是这样用。然而由于URI路径实际上并非Javascript来处理，而是为页面DOM属性赋值，由浏览器来处理相对路径，因此所有相对路径的起算路径均为当前页面路径而非


### CSS

### HTML

### 浏览器

在我们的网站功能逐渐丰富、业务日益复杂后，我们虽然通过模块化能力Hold住了开发层面的问题，我们还需要解决网站加载速度方面的问题。如果将所有模块都独立加载的话，很快的我们就会发现网站加载速度奇慢无比，要是在掉包严重的移动网络上加载的话，这个问题就会更加严重。解决办法自然是很传统的文件打包，当然打包的形式有很多种，目前与RequireJs这类模块加载器最合拍的打包加载方式应该就是Combo服务了。